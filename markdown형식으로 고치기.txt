https://www.inflearn.com/course/%EC%9C%A0%EB%8B%88%ED%8B%B0-%EA%B0%95%EC%A2%8C-unity/
http://www.androidpub.com/index.php?document_srl=1851206&mid=devfree&cpage=1#comment

hierarchy project의 경우는 메모리 ....


어딘가의 ..--> 

project 항상주시 유니티에서 메타데이터를 항상관리 저장일이 언제다 이런것들의 저장 
씬파일---> 하나의 장면을 하나의 파일로 저장


씬과 게임 

씬은 우리가 감독

게임은 카메라가 보는 시점 


ctrl + s --> asset에 씬 생성


ctrl + d ---> 복사



컴포넌트 환경 

옛날식 프로그래밍 --> 
플레이어라는 것을 통으로 만듬  // 플레이어가 공격하는 기능 
몬스터 플레이어에게 맞는 기능 , 총알 몬스터를 아프게 때리는 기능     하나하나를 매번 새롭게 만듬 객체

but unity  컴포넌트 기반  
이미지가 보이는 기능 
공격하는 기능 

ex 자동차의 뼈대만 있고 기능들은 따로 추가할 수 있음 적절한 기능을 추가해줌 

몬스터(Game Object)가 "나타난다(function)" 라는 의미가 

Cube --> obj
Camera --> obj + function(obj에 필요한 기능) 




opengl의 좌표가 있다 --> 위치
obj --> 크기, 위치 , 회전  어떤 좌표에서 어느정도의 크기로 얼마만큼의 회전으로 opengl에서 배운것과 같다.

transform


camera

clear flag -->  화면을 싹 밀어버릴 때 어떤식으로 지울래 
frame과 같은 원리로 순간적으로 이루어짐
background --> 단색을 무슨 색으로 정할지
culling mask --> 액터, 스킬로 분류된 그룹이 있을 때 선택적으로 볼 수 있음
projection --> 원근법이 있는 것 Orthographic(2D 근본적으로는 3D이지만 시야에는 ex, size issue, speed를 정할 수 있다) -->원근법삭제 
field of view --> 화각 : 카메라의 시야각 
near && far --> 화면에 상이 맺히는 최소 거리와 최대 거리 

범용적인 기능은 제공하나 원하는 기능은 제공하지않는다 , 즉 만들어야한다.


스크립트 ? -> 기본적으로 제공하는 기능을 토대로 원하는 기능을 구현하기 위함

파일 하나 생김


Debug 게임 실행 도중에 어떤 문자를 확인하고 싶다면 
: 스타트는 한번 만든다.


rigidbody 

use gravity 

edit -> project setting -> phisics

2D에서의 충돌연산은 상대적으로 가벼운 편이다.

유니티에서의 물리는 2가지를 기준으로 구성되게 된다.

첫 번째, 리지드바디(3D/2D) 충돌도 담당하지만 물리측면도 담당한다.
두 번째, 컬라이더(충돌을 위한 범위를 담당한다.)

리지드바디가 어떤 컬라이더와 부딪힌다.

충돌은 일반적으로 

점
선
회전하지 않은 사각형
단위원에서 확장된 원
회전한 사각형 OBB


center 충돌체의 중심
size 충돌체의 크기


물리적 충돌에 의한 값을 조정할 수 있다

Freeze Position
Freeze Rotation
